stages:
  - lint
  - test
  - sonar
  - build
  - docker
  - release

variables:
  PYTHON_VERSION: "3.10"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# Template pour la configuration Python de base
.python_template: &python_template
  image: python:3.10
  before_script:
    - python -m pip install --upgrade pip
    - pip install --cache-dir $PIP_CACHE_DIR -r requirements-dev.txt
  cache:
    key: 
      files:
        - requirements-dev.txt
        - requirements.txt
    paths:
      - .cache/pip/
      - .tox/
    policy: pull-push

# Stage: Lint - Qualit√© du code
lint:
  <<: *python_template
  stage: lint
  script:
    - echo "üîç Running code quality checks..."
    - black --check --diff .
    - isort --check-only --diff .
    - flake8 .
  artifacts:
    reports:
      junit: lint-report.xml
    paths:
      - lint-report.xml
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Stage: Test - Tests unitaires et couverture
test:
  <<: *python_template
  stage: test
  parallel:
    matrix:
      - PYTHON_VERSION: ["3.8", "3.9", "3.10", "3.11", "3.12"]
  image: python:${PYTHON_VERSION}
  script:
    - echo "üß™ Running tests with Python ${PYTHON_VERSION}..."
    - pip install tox tox-gh-actions
    - tox
    - |
      if [ "$PYTHON_VERSION" = "3.10" ]; then
        echo "üìä Generating coverage report..."
        pytest --cov=src --cov-report=xml --cov-report=html --junitxml=pytest-report.xml
      fi
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      junit: pytest-report.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
      - htmlcov/
      - pytest-report.xml
      - .coverage
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Stage: Test de r√©gression
test:regression:
  <<: *python_template
  stage: test
  script:
    - echo "üîÑ Running regression tests..."
    - python -m pytest test_regression.py -v --tb=short
  artifacts:
    paths:
      - test_snapshots/
    expire_in: 1 week
    when: on_failure
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Stage: Sonar - Analyse de qualit√©
sonar:
  stage: sonar
  image: 
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - echo "üîç Running SonarQube analysis..."
    - sonar-scanner
      -Dsonar.projectKey=$CI_PROJECT_PATH_SLUG
      -Dsonar.sources=src/
      -Dsonar.tests=tests/
      -Dsonar.python.coverage.reportPaths=coverage.xml
      -Dsonar.python.xunit.reportPath=pytest-report.xml
      -Dsonar.host.url=$SONAR_HOST_URL
      -Dsonar.login=$SONAR_TOKEN
  dependencies:
    - test
  artifacts:
    paths:
      - .sonar/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
    - if: $CI_COMMIT_TAG

# Stage: Build - Construction des ex√©cutables
build:executable:
  <<: *python_template
  stage: build
  parallel:
    matrix:
      - OS: ["linux", "windows", "macos"]
  script:
    - echo "üî® Building executable for ${OS}..."
    - pip install --cache-dir $PIP_CACHE_DIR -r requirements.txt
    - pip install pyinstaller
    - pyinstaller wigor.spec
    - |
      if [ -f "dist/wigor" ]; then
        ./dist/wigor --version
        ./dist/wigor --check
        echo "‚úÖ Linux executable built and tested successfully"
      elif [ -f "dist/wigor.exe" ]; then
        echo "‚úÖ Windows executable built (cross-platform)"
      fi
  artifacts:
    name: "wigor-${OS}-${CI_COMMIT_SHORT_SHA}"
    paths:
      - dist/
      - build/
    expire_in: 1 month
  dependencies:
    - lint
    - test
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual

# Stage: Build - S√©curit√©
build:security:
  <<: *python_template
  stage: build
  script:
    - echo "üîí Running security scans..."
    - pip install bandit safety
    - bandit -r src/ -f json -o bandit-report.json || true
    - pip install -r requirements.txt
    - safety check --json --output safety-report.json || true
    - echo "Security scan completed"
  artifacts:
    paths:
      - bandit-report.json
      - safety-report.json
    expire_in: 1 week
    when: always
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Stage: Docker - Construction de l'image
docker:build:
  stage: docker
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - docker info
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üê≥ Building Docker image..."
    - docker build --pull -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - echo "üß™ Testing Docker image..."
    - docker run --rm $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA --version
    - docker run --rm $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA --check
    - echo "‚úÖ Docker image built and tested successfully"
  after_script:
    - docker logout $CI_REGISTRY
  dependencies:
    - lint
    - test
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Stage: Docker - Push vers le registre
docker:push:
  stage: docker
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - docker info
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üì¶ Pushing Docker image to registry..."
    - docker build --pull -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        echo "‚úÖ Tagged image pushed: $CI_COMMIT_TAG"
      fi
    - docker push $CI_REGISTRY_IMAGE:latest
    - echo "‚úÖ Images pushed successfully"
  after_script:
    - docker logout $CI_REGISTRY
  dependencies:
    - docker:build
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Stage: Release - Cr√©ation des releases
release:prepare:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "üìã Preparing release assets..."
    - mkdir -p release-assets
    - |
      for artifact in dist/*; do
        if [ -f "$artifact" ]; then
          cp "$artifact" release-assets/
          echo "Added $(basename "$artifact") to release assets"
        fi
      done
    - ls -la release-assets/
    - echo "Release preparation completed"
  artifacts:
    name: "wigor-release-${CI_COMMIT_TAG}"
    paths:
      - release-assets/
    expire_in: 1 year
  dependencies:
    - build:executable
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+.*$/

# Stage: Release - Publication GitHub/GitLab
release:publish:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  script:
    - echo "üöÄ Creating GitLab release for tag $CI_COMMIT_TAG..."
  release:
    name: 'Release $CI_COMMIT_TAG'
    description: |
      ## üéâ WigorViewer $CI_COMMIT_TAG

      ### üì¶ Assets included:
      - Cross-platform executables (Linux, Windows, macOS)
      - Docker image: `$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG`
      
      ### üîó Links:
      - [Docker Registry]($CI_REGISTRY_IMAGE)
      - [Pipeline]($CI_PIPELINE_URL)
      
      ---
      *Generated automatically by GitLab CI/CD*
    tag_name: '$CI_COMMIT_TAG'
    assets:
      links:
        - name: 'Linux Executable'
          url: '$CI_JOB_URL/artifacts/raw/release-assets/wigor'
          filepath: '/wigor-linux'
        - name: 'Windows Executable' 
          url: '$CI_JOB_URL/artifacts/raw/release-assets/wigor.exe'
          filepath: '/wigor-windows.exe'
        - name: 'Docker Image'
          url: '$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG'
  dependencies:
    - release:prepare
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+.*$/

# Stage: Release - D√©ploiement production
release:deploy:
  stage: release
  image: alpine:latest
  environment:
    name: production
    url: https://wigor-viewer.example.com
  before_script:
    - apk add --no-cache curl
  script:
    - echo "üöÄ Deploying to production..."
    - echo "Image deployed: $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
    - |
      # Exemple de d√©ploiement (√† adapter selon votre infrastructure)
      # kubectl set image deployment/wigor-viewer wigor-viewer=$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
      # docker-compose -f docker-compose.prod.yml up -d
      echo "‚úÖ Production deployment completed"
  dependencies:
    - docker:push
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/ # Tags stables uniquement
      when: manual
  allow_failure: false

# Jobs de nettoyage et maintenance
cleanup:
  stage: .post
  image: alpine:latest
  script:
    - echo "üßπ Cleaning up temporary files..."
    - rm -rf .cache/
    - rm -rf .tox/
    - echo "Cleanup completed"
  rules:
    - when: always
  allow_failure: true

# Job de notification
notify:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      if [ "$CI_JOB_STATUS" = "success" ]; then
        echo "‚úÖ Pipeline completed successfully!"
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"üöÄ WigorViewer pipeline succeeded for '"$CI_COMMIT_REF_NAME"'"}' \
        #   $SLACK_WEBHOOK_URL
      else
        echo "‚ùå Pipeline failed!"
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"üí• WigorViewer pipeline failed for '"$CI_COMMIT_REF_NAME"'"}' \
        #   $SLACK_WEBHOOK_URL
      fi
  rules:
    - when: always
  allow_failure: true